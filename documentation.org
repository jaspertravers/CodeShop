#+TITLE: codeshop Documentation
* Development
- Internal representation and passing of code
- CM highlighting, scrolling?
- CM saving
- code transformation/formatting and passing between CM \rarr S
  - Maybe I should be using =json= or =edn=
- How does repl.it solve the "halting problem"?
- Drag and Drop wm
- creat new Pair component for stdlib functions
- CodeMirror should only contain codemirror logic; playbutton should be in a different place
** Code Organization
=CodeMirror.svelte= exports ~code~ and the event dispatcher ~dispatch~ through the line:
#+begin_src js
dispatch('change', code);
#+end_src
this dispatch call is listened to by ~Group.svelte~ where the instantiation of the =CodeMirror= component by:
#+begin_src html
<CodeMirror code={initial} on:change={update}/>
#+end_src
connects the local function ~update~ to the dispatch key ~'change'~ by the syntax ~on:change{update}~
The local function ~update~ passes an error-checked function object to be rendered by p5js in =Sketch.svelte=
#+begin_src js
function update ({detail: sourceCode}) {
#+end_src

#+begin_src sh :exports both
cd src
~/scripts/ff update
#+end_src

#+RESULTS:
: ./Group.svelte

** Feature Work
Functions are currently being added to a library, accessible within sketch components as ~lib.~ They could also be simply appended to the same function instantiation as structured below
#+begin_src js
function setup () {...}
function draw () {...}
...
function linspace () {...}
#+end_src
adding functions at =...= would circumvent the prefix ~lib.~ There are certainly advantages to both.

* Ideas and Explanations
** Functions in javascript
#+begin_src js
args = ['a', 'b']
body = 'return a + b'
sum = new Function (...args, body)
return sum (2,3)
#+end_src

#+RESULTS:
: 5

I want to be able to write into the editor:
#+begin_src js
// get n numbers evenly distributed between (mi, ma).
// includes the end values.
function linspace (n, mi, ma) {
  let res = [];
  const s = (ma - mi) / (n-1);
  let y = mi;
  for (let i = 0; i < n; i++){
      res.push(y);
      y += s;
  }
  return res;
}
return linspace(9,0,10)
#+end_src

** Library and Closure
#+begin_src js
const library = Object.keys($runtime).reduce((acc, fName)  => {
  const functionObj = (new Function(`return ${$runtime[fName]}`))();
  acc[fName] = functionObj;
  return acc;
}, {});

const closure = new Function (
  `return function(lib) {
    return ${sourceCode}
  }`
)();

sketch = closure(library);
#+end_src

running ~s1~ and ~linspace~
~library~ becomes ~{s1: f, linspace: f}~

~closure~  becomes, literally:
#+begin_src js
(function anonymous() {
  return function(lib) {
    return (p) => {
      //local vars
      p.setup = () => {...}
      p.draw = () => {...}
    }
  }
})
#+end_src
and is then immediately called by the ending ~()~ to unroll the one anonymous function resulting in:
#+begin_src js
return function(lib) {
    return (p) => {
      //local vars
      p.setup = () => {...}
      p.draw = () => {...}
    }
}
#+end_src

so finally, the "driver"
#+begin_src js
sketch = closure(library);
#+end_src
passes ~library~ which is an object whose keys are other functions. In this way, any code may access other functions embeded in the ~lib~ object by ~lib.function()~

** Inputs (Sliders)
Parameters passed to the sketch element, instead of 
#+begin_src js
(p) => {...}
#+end_src
having
#+begin_src js
(p, [...sliders]) => {...}
#+end_src
* Conversations
Joe Politz asked something about how this would compare to jsFiddle. My answer was that I could imagine this service as a workspace of fiddles. The fundamental idea of this work is to give a ~*-*~ relationship between code and outpus. I'll have to work on this analogy.
I want a high level of granularity in selecting and writing code. (Code is not divided by file, but by function or groups)
This project currently has a higher level of distinction between blocks of code than even Observable/Jupyter because of the horizontal grouping with output. There is much work to do here, but it allows another "hook" of organization to have horizontal layout over a single scrolling column. 
* Notes
- Observable must thread their function boxes
- How does repl.it work?
** Related Services
| Service     | Site                   |
|-------------+------------------------|
| Observable  |                        |
| Ronin       |                        |
| Jupyter     |                        |
| jsFiddle    |                        |
| Codepen     |                        |
| pythontutor |                        |
| codesandbox | https://codesandbox.io |
** Related Technologies
- eval()
- new Function()
- localStorage
- canvas
- web workers

*** Links and code
  
https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API
https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial
https://simon.html5.org/dump/html5-canvas-cheat-sheet.html

 https://stackoverflow.com/a/19655815/9346730

#+begin_src js
/*
 * https://stackoverflow.com/a/19655815/9346730
 * @param fun the function to carry out in the web worker
 * @param mes the message to send to the web worker
 * @param com the function to do on completion
 * creates, dispatches & receives a web worker
 */
function wor(fun, mes, com) {
   var wor = new Worker(URL.createObjectURL(new Blob([
         'self.onmessage = ' + fun.toString()], {
         type: 'application/javascript'
   })));       
   wor.postMessage(mes);
   wor.onmessage = com;
}
#+end_src
